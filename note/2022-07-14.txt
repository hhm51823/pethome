
    无状态token方案：
        用户登录后生成token，将token和用户信息到redis中。
        将token返回给前端，前端发起请求需要携带token
        后端在拦截器中根据token查询redis判断用户是否登录

        如果要实现权限，需要将用户的权限封装到logininfo中一并返回给前端
        存在以下问题：
            1，每次请求都需要查询redis效率低
            2，redis存储数据过多会影响性能
            3，浏览器端保存的数据都是明文，非常不安全

    jwt方案：
        简单的说就是：
        用户登录后查询出所有信息，将所有信息加密成一个jwt字符串
        前端解密jwt字符串就能获取到用户的所有信息和权限
        前端每次请求都携带jwt

    加密方案：
        不可逆加密算法：
            MD5
            不能解密，一般用作对密码的对比

        可逆对称加密算法：
            特点：可以加密也可以解密，加密和解密使用同一个密钥。
            常见技术：DES AES

            问题，在数据传输时不安全，网络可以拦截到秘钥然后解密或伪造数据

        可逆非对称加密算法：
            有一对密钥：公钥和私钥。公钥加密，只能使用私钥解密。私钥加密，只能使用公钥加密。
            实现技术：RSA， RSA2

            问题：数据网络传输中虽然不能破解密文，但能通过公钥加密信息进行伪造，依然存在安全问题


        RSA双重加密
            有A客户端，B服务端。A，B均有自己的公钥和私钥

            如登录：
                A客户端：
                    1，A将用户的信息通过B的公钥加密
                    2，A将加密一次后的信息使用A的私钥再次加密  --签名

                B服务端：
                    1，使用A的公钥解密  --签名认证
                    2，使用B的私钥解密  --获取信息

            恶意攻击可以通过A的公钥获取第一次加密的密文，但无法破解，也无法伪造签名。


    jwt：JSON Web Token，该规范允许我们使用jwt在用户和服务器之间传递安全可靠的信息。

    组成：头部(header)：声明类型和加密算法
         载荷(payload)：保存用户相关的数据
         签证信息(signature)：通过指定的算法生成哈希，用来确定身份，验证JWT串是自己发出去的


    jwt准备：
        本项目只实现了后端的部分。
        1，生成公钥和私钥
        2，编写加密解密工具类
        3，导入相关依赖
        4，编写载荷数据对象payload
            jwt唯一标识
            用户信息
            过期时间
        5，编写UserInfo对象保存logininfo信息，URL权限的sn，菜单权限

    登录接口修改：
        密码校验通过后查询到logininfo如果是管理员执行以下步骤。
        以下步骤所有的登录接口都适用
        1，根据logininfo的id查询到该员工的URL权限的SN属性的集合
        2，根据logininfo的id查询到该员工的菜单权限的集合
            查询一级菜单，将二级菜单封装到一级菜单的children属性中
        3，将SN属性集合，菜单结合和logininfo封装到UserInfo对象中
        4，拿到私钥，盗用工具类的加密方法将数据加密为Jwt字符串。
        5，将jwt字符串放入返回给前端的map中
        以下为多余步骤，因为前端没做jwt
        6，将SN属性集合，菜单结合和logininfo清空敏感信息后放入返回给前端的map中

    拦截器修改：
        1，验证传回的jwt是否为空
        2，获取公钥解密jwt得到payload对象
        3，判断payload对象是否为空，为空则表示未登录
        4，从payload对象取出UserInfo，再从UserInfo中取出logininfo判断type
            前台用户直接放行，后台继续
        5，从UserInfo中获取到SN集合
        6，获得该请求接口的自定义注解的sn属性值
            1，得到本次请求的方法对象
                HandlerMethod handlerMethod = (HandlerMethod) handler;
            2，通过方法对象获取方法上的指定注解
            3，判断注解是否存在
                不存在则放行，表示该接口访问的是公共资源
            4，从注解中拿到sn属性的值
        7，判断SN集合中是否包含该sn
            包含则放行，不包含则返回无权限访问


    前端实现菜单权限控制：
        有权限则展示，无权限不展示;
        使用动态路由：

            1，删除路由配置文件中的非公共路由
            2，在登录组件中
                1，将后端传递的数据保存到localStorage中
                2，编写动态添加路由函数，从后端传过来的菜单集合中获取组件路径和路由路径实现动态添加路由
                3，在登录成功的回调函数中调用
            3，在main.js中编写动态添加路由函数，且自调用依次（解决登陆后，刷新页面路由失效问题）
            4，在路由拦截器的登录注册放行时
                1，判断jwttoken是否存在
                2，存在则清空localStorage中的数据
                3，清空路由缓存
            5，点击退出时也需清空jwttoken和路由缓存
                这种退出不需要调用退出接口了

    按钮权限控制：
        没有权限则删除按钮组件

        创建一个js文件自定义Vue属性
            1，获取到员工的sn集合，判断该按钮绑定的值是否包含在其中。
            2，不包含则删除该组件
        在main.js中引入该js文件

        在所有需要权限的按钮上绑定该自定义属性，绑定sn值
